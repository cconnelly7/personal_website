{"ast":null,"code":"var _jsxFileName = \"/Users/Chianne/Desktop/personal-website/src/app/Glance.js\";\nimport React from 'react';\nimport './Project.css';\nimport $ from 'jquery';\n$(function () {\n  var shrinkHeader = 200;\n  $(window).scroll(function () {\n    var scroll = getCurrentScroll();\n\n    if (scroll >= shrinkHeader) {\n      $('.projPic').addClass('shrink');\n    } else {\n      $('.projPic').removeClass('shrink');\n    }\n  });\n\n  function getCurrentScroll() {\n    return window.pageYOffset || document.documentElement.scrollTop;\n  }\n});\n$(document).ready(function () {});\n\nclass ScrollToTopOnMount extends React.Component {\n  componentDidMount() {\n    window.scrollTo(0, 0);\n  }\n\n  render() {\n    return null;\n  }\n\n}\n\nfunction Glance() {\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38\n    },\n    __self: this\n  }, React.createElement(ScrollToTopOnMount, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39\n    },\n    __self: this\n  }), React.createElement(\"div\", {\n    class: \"projPic\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40\n    },\n    __self: this\n  }, React.createElement(\"h4\", {\n    class: \"projHeader\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 41\n    },\n    __self: this\n  }, \"Computer Graphics Series\")), React.createElement(\"div\", {\n    class: \"projBg\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 43\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    class: \"projContent\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 44\n    },\n    __self: this\n  }, React.createElement(\"img\", {\n    class: \"banner\",\n    src: \"./Projects/ComputerGraphics/WalkerBanner.png\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45\n    },\n    __self: this\n  }), React.createElement(\"h4\", {\n    class: \"sectionHeader\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 46\n    },\n    __self: this\n  }, \"Overview\"), React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 47\n    },\n    __self: this\n  }, \" In this series I applied concepts and algorithms to create, analyze, display, and animate shapes and structures and let the user design or control them interactively.\"), React.createElement(\"br\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 48\n    },\n    __self: this\n  }), React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 49\n    },\n    __self: this\n  }, \"The series began by implementing  a cubic Neville and a Bezier curve and applying an animation of dots moving along the curve with uniform, centripetal, and chordal knot spacing. The next feature I implemented was a circular arc implementation to visualize a Bezier curve rather than using a linear interpolation. The first arc segment begins at point A and ends at the midpoint of BC. Likewise, the second arc segment begins as the midpoint of BC and ends at point D. In order to create a smooth curve, the arcs endpoint must be tangent to BC. Law of cosine was used to find the missing angle in the triangle ABMidpoint. Knowing this angle, law of sine could be used to find the radius of the arc segment. Lastly, this information could be used to find the center point of the arc segment. If the user presses \\u201Ce,\\u201D they can toggle the line segments used in finding the radius and center coordinates. I then created a way to visualize how the Bezier curve gets constructed through the underlying liner interpolation function. It shows how the Bezier curve is a series of straight lines rather than a smooth curve. Also shown by this view are the intermediate curves created by the Bezier curve between ABC and BCD. These curves get combined to create the final Bezier curve.\"), React.createElement(\"div\", {\n    class: \"imgContainer\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57\n    },\n    __self: this\n  }, React.createElement(\"img\", {\n    class: \"image2\",\n    src: \"./Projects/ComputerGraphics/cg0.png\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58\n    },\n    __self: this\n  }), React.createElement(\"img\", {\n    class: \"image2\",\n    src: \"./Projects/ComputerGraphics/cg1.png\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 59\n    },\n    __self: this\n  }), React.createElement(\"img\", {\n    class: \"image2\",\n    src: \"./Projects/ComputerGraphics/cg2.png\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 60\n    },\n    __self: this\n  }), React.createElement(\"img\", {\n    class: \"image2\",\n    src: \"./Projects/ComputerGraphics/cg3.png\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61\n    },\n    __self: this\n  }), React.createElement(\"span\", {\n    class: \"stretch\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62\n    },\n    __self: this\n  })), React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64\n    },\n    __self: this\n  }, \"In the next part of this series, I created a runner that followed a path that could be manipulated by the user. I first found the acceleration vector between the subdivision points of some control points. Next, I used the acceleration vectors to generate a curve along the floor. I used this as my footpath. To make the feet move, I count the frames and move the feet in cycles of 18 frames. I made legs with knees and calculated the knee points by using the foot location, forward direction, and hip location. I added a multiplier to the knee to vary how much it bends while it is moving. This was just to make it prettier. I added hips that tilt based on the cross product of the acceleration vector and forward direction. I used a similar method to calculate the shoulders, as well as to add bending arms. The feet move up and down as the runner is taking steps.\"), React.createElement(\"img\", {\n    class: \"image1\",\n    src: \"./Projects/ComputerGraphics/walker.gif\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 71\n    },\n    __self: this\n  }), React.createElement(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 72\n    },\n    __self: this\n  }, \"To finish off the series I explored applications of triangle meshes to collision avoidance, path planning, visibility analysis, and ray tracing. To begin, I first got the Robot and the pillars to appear. I then made a RobotTarget point. This started off as the same point as the Robot. When the Robot reaches the RobotTarget a new center point is chosen to be the new RobotTarget. As the Robot moves I change its height and radius such that the Robot maintains the same volume while traversing through the pillars. In the next step, I made the Robot \\u201Cclean the floor\\u201D by writing an algorithm that makes sure the Robot travels to all of the triangles within the mesh. In this algorithm, the distances to all of the circumcenters were checked and the Robot chose the closest uncleaned circumcenter as its new RobotTarget.\"), React.createElement(\"div\", {\n    class: \"imgContainer\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 79\n    },\n    __self: this\n  }, React.createElement(\"img\", {\n    class: \"image3\",\n    src: \"./Projects/ComputerGraphics/cg.3.0.gif\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80\n    },\n    __self: this\n  }), React.createElement(\"img\", {\n    class: \"image3\",\n    src: \"./Projects/ComputerGraphics/cg.3.1.gif\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 81\n    },\n    __self: this\n  })))));\n}\n\nexport default Glance;","map":{"version":3,"sources":["/Users/Chianne/Desktop/personal-website/src/app/Glance.js"],"names":["React","$","shrinkHeader","window","scroll","getCurrentScroll","addClass","removeClass","pageYOffset","document","documentElement","scrollTop","ready","ScrollToTopOnMount","Component","componentDidMount","scrollTo","render","Glance"],"mappings":"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","sourcesContent":["import React from 'react';\nimport './Project.css';\nimport $ from 'jquery';\n\n$(function(){\n  var shrinkHeader = 200;\n   $(window).scroll(function() {\n     var scroll = getCurrentScroll();\n       if ( scroll >= shrinkHeader ) {\n            $('.projPic').addClass('shrink');\n         }\n         else {\n            $('.projPic').removeClass('shrink');       \n         }\n   });\n function getCurrentScroll() {\n     return window.pageYOffset || document.documentElement.scrollTop;\n     }\n});\n \n $(document).ready(function(){ })\n\n\nclass ScrollToTopOnMount extends React.Component {\n  componentDidMount() {\n    window.scrollTo(0, 0);\n  }\n\n  render() {\n    return null;\n  }\n}\n \n \n\nfunction Glance() {\n    return(\n      <div>\n        <ScrollToTopOnMount />\n        <div class=\"projPic\">\n          <h4 class='projHeader'>Computer Graphics Series</h4>\n        </div>\n        <div class=\"projBg\">\n          <div class=\"projContent\">\n            <img class=\"banner\" src=\"./Projects/ComputerGraphics/WalkerBanner.png\"></img>\n            <h4 class='sectionHeader'>Overview</h4>\n            <p> In this series I applied concepts and algorithms to create, analyze, display, and animate shapes and structures and let the user design or control them interactively.</p>\n            <br/>\n            <p>The series began by implementing  a cubic Neville and a Bezier curve and applying an animation of dots moving along the curve with uniform, centripetal, and chordal knot spacing.\n               The next feature I implemented was a circular arc implementation to visualize a Bezier curve rather than using a linear interpolation. The first arc segment begins at point\n               A and ends at the midpoint of BC. Likewise, the second arc segment begins as the midpoint of BC and ends at point D. In order to create a smooth curve, the arcs endpoint must\n                be tangent to BC. Law of cosine was used to find the missing angle in the triangle ABMidpoint. Knowing this angle, law of sine could be used to find the radius of the arc\n                 segment. Lastly, this information could be used to find the center point of the arc segment. If the user presses “e,” they can toggle the line segments used in finding\n                  the radius and center coordinates. I then created a way to visualize how the Bezier curve gets constructed through the underlying liner interpolation function. It shows how the Bezier curve is a series of straight\n             lines rather than a smooth curve. Also shown by this view are the intermediate curves created by the Bezier curve between ABC and BCD. These curves get combined to create the final Bezier curve.\n            </p>\n            <div class=\"imgContainer\">\n              <img class=\"image2\" src=\"./Projects/ComputerGraphics/cg0.png\"></img>\n              <img class=\"image2\" src=\"./Projects/ComputerGraphics/cg1.png\"></img>\n              <img class=\"image2\" src=\"./Projects/ComputerGraphics/cg2.png\"></img>\n              <img class=\"image2\" src=\"./Projects/ComputerGraphics/cg3.png\"></img>\n              <span class=\"stretch\"></span>\n            </div>\n            <p>\n            In the next part of this series, I created a runner that followed a path that could be manipulated by the user. I first found the acceleration vector between the subdivision points\n             of some control points. Next, I used the acceleration vectors to generate a curve along the floor. I used this as my footpath. To make the feet move, I count the frames and move the\n              feet in cycles of 18 frames. I made legs with knees and calculated the knee points by using the foot location, forward direction, and hip location. I added a multiplier to the knee\n               to vary how much it bends while it is moving. This was just to make it prettier. I added hips that tilt based on the cross product of the acceleration vector and forward direction.\n                I used a similar method to calculate the shoulders, as well as to add bending arms. The feet move up and down as the runner is taking steps.\n            </p>\n            <img class=\"image1\" src=\"./Projects/ComputerGraphics/walker.gif\"></img>\n            <p>\n            To finish off the series I explored applications of triangle meshes to collision avoidance, path planning, visibility analysis, and ray tracing. To begin, I first got the Robot and the\n             pillars to appear. I then made a RobotTarget point. This started off as the same point as the Robot. When the Robot reaches the RobotTarget a new center point is chosen to be the new\n              RobotTarget. As the Robot moves I change its height and radius such that the Robot maintains the same volume while traversing through the pillars. In the next step, I made the Robot\n               “clean the floor” by writing an algorithm that makes sure the Robot travels to all of the triangles within the mesh. In this algorithm, the distances to all of the circumcenters were\n                checked and the Robot chose the closest uncleaned circumcenter as its new RobotTarget.\n            </p>\n            <div class=\"imgContainer\">\n              <img class=\"image3\" src=\"./Projects/ComputerGraphics/cg.3.0.gif\"></img>\n              <img class=\"image3\" src=\"./Projects/ComputerGraphics/cg.3.1.gif\"></img>\n            </div>\n          </div>\n        </div>\n      </div>\n    )\n}\n\nexport default Glance;"]},"metadata":{},"sourceType":"module"}